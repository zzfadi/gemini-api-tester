<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini API Tester</title>
    <meta name="description" content="Gemini API Tester — Test Gemini & Veo APIs">
    
    <!-- Distinctive fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=Instrument+Serif:ital@0;1&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* Amber CRT palette */
            --amber-glow: #ffb000;
            --amber-dim: #cc8800;
            --amber-bright: #ffd966;
            --amber-text: #ffe4a0;
            
            /* Deep geological darks */
            --obsidian: #0a0a0c;
            --basalt: #12121a;
            --slate: #1a1a24;
            --shale: #252532;
            
            /* Accent minerals */
            --malachite: #00d9a0;
            --azurite: #00a8ff;
            --cinnabar: #ff4444;
            --sulfur: #e8e800;
            
            /* Functional */
            --success: var(--malachite);
            --warning: var(--sulfur);
            --error: var(--cinnabar);
            --info: var(--azurite);
            
            /* Typography */
            --font-mono: 'IBM Plex Mono', 'Fira Code', monospace;
            --font-display: 'Instrument Serif', Georgia, serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: 15px;
        }

        body {
            font-family: var(--font-mono);
            background: var(--obsidian);
            color: var(--amber-text);
            min-height: 100vh;
            line-height: 1.6;
            position: relative;
            overflow-x: hidden;
        }

        /* Scanline overlay - exclude media previews */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.15) 2px,
                rgba(0, 0, 0, 0.15) 4px
            );
            pointer-events: none;
            z-index: 9999;
        }

        /* CRT vignette - exclude media previews */
        body::after {
            content: '';
            position: fixed;
            inset: 0;
            background: radial-gradient(
                ellipse at center,
                transparent 0%,
                transparent 60%,
                rgba(0, 0, 0, 0.4) 100%
            );
            pointer-events: none;
            z-index: 9998;
        }

        /* Noise texture - exclude media previews */
        .noise-overlay {
            position: fixed;
            inset: 0;
            opacity: 0.03;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 9997;
        }

        /* Media preview - higher z-index to appear above overlays */
        .media-preview {
            position: relative;
            z-index: 10000;
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 2rem 1.5rem;
            position: relative;
        }

        /* ===== HEADER ===== */
        header {
            text-align: center;
            padding: 3rem 0 2.5rem;
            position: relative;
        }

        .logo-mark {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 80px;
            height: 80px;
            border: 2px solid var(--amber-dim);
            border-radius: 50%;
            margin-bottom: 1.5rem;
            position: relative;
            animation: pulse-glow 3s ease-in-out infinite;
        }

        .logo-mark::before {
            content: '';
            position: absolute;
            inset: -8px;
            border: 1px solid var(--amber-dim);
            border-radius: 50%;
            opacity: 0.3;
        }

        .logo-mark svg {
            width: 40px;
            height: 40px;
            fill: var(--amber-glow);
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 176, 0, 0.2); }
            50% { box-shadow: 0 0 40px rgba(255, 176, 0, 0.4); }
        }

        h1 {
            font-family: var(--font-display);
            font-size: 2.8rem;
            font-weight: 400;
            font-style: italic;
            color: var(--amber-glow);
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 30px rgba(255, 176, 0, 0.3);
        }

        .subtitle {
            font-size: 0.8rem;
            color: var(--amber-dim);
            text-transform: uppercase;
            letter-spacing: 0.3em;
        }

        .header-line {
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--amber-dim), transparent);
            margin-top: 2rem;
        }

        /* ===== API KEY SECTION ===== */
        .api-key-section {
            background: var(--basalt);
            border: 1px solid var(--shale);
            padding: 1.5rem;
            margin-bottom: 2rem;
            position: relative;
        }

        .api-key-section::before {
            content: 'AUTHENTICATION';
            position: absolute;
            top: -0.6rem;
            left: 1rem;
            background: var(--basalt);
            padding: 0 0.5rem;
            font-size: 0.65rem;
            color: var(--amber-dim);
            letter-spacing: 0.2em;
        }

        .input-row {
            display: flex;
            gap: 0.75rem;
            align-items: stretch;
        }

        .input-wrapper {
            position: relative;
            flex: 1;
            display: flex;
        }

        .input-wrapper input {
            flex: 1;
            padding-right: 2.5rem;
        }

        .toggle-visibility-btn {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            color: var(--amber-dim);
            cursor: pointer;
            padding: 0.25rem;
            font-size: 1rem;
            line-height: 1;
            opacity: 0.6;
            transition: opacity 0.15s;
        }

        .toggle-visibility-btn:hover {
            opacity: 1;
            background: transparent;
        }

        .toggle-visibility-btn::before {
            display: none;
        }

        input[type="password"],
        input[type="text"],
        textarea,
        select {
            flex: 1;
            padding: 0.75rem 1rem;
            background: var(--obsidian);
            border: 1px solid var(--shale);
            color: var(--amber-text);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: var(--amber-dim);
            box-shadow: 0 0 0 1px var(--amber-dim), inset 0 0 20px rgba(255, 176, 0, 0.05);
        }

        input::placeholder,
        textarea::placeholder {
            color: rgba(255, 228, 160, 0.3);
        }

        /* Buttons */
        button {
            padding: 0.75rem 1.25rem;
            background: transparent;
            border: 1px solid var(--amber-dim);
            color: var(--amber-glow);
            font-family: var(--font-mono);
            font-size: 0.8rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--amber-glow);
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        button:hover {
            background: rgba(255, 176, 0, 0.1);
            box-shadow: 0 0 20px rgba(255, 176, 0, 0.2);
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        button.primary {
            background: var(--amber-glow);
            color: var(--obsidian);
            font-weight: 600;
        }

        button.primary:hover {
            background: var(--amber-bright);
        }

        button.small {
            padding: 0.5rem 0.75rem;
            font-size: 0.7rem;
        }

        .validation-result {
            margin-top: 1rem;
            font-size: 0.85rem;
        }

        /* ===== TABS ===== */
        .tabs {
            display: flex;
            gap: 0;
            margin-bottom: 0;
            border-bottom: 1px solid var(--shale);
        }

        .tab {
            padding: 1rem 1.5rem;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--amber-dim);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .tab:hover {
            color: var(--amber-text);
            background: rgba(255, 176, 0, 0.03);
            box-shadow: none;
            transform: none;
        }

        .tab.active {
            color: var(--amber-glow);
            border-bottom-color: var(--amber-glow);
            background: rgba(255, 176, 0, 0.05);
        }

        .tab-icon {
            margin-right: 0.5rem;
            font-size: 1rem;
        }

        /* ===== TEST PANELS ===== */
        .test-panel {
            display: none;
            background: var(--basalt);
            border: 1px solid var(--shale);
            border-top: none;
            padding: 2rem;
        }

        .test-panel.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .panel-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--shale);
        }

        .panel-header h3 {
            font-family: var(--font-display);
            font-size: 1.6rem;
            font-weight: 400;
            font-style: italic;
            color: var(--amber-glow);
        }

        .panel-header p {
            font-size: 0.8rem;
            color: var(--amber-dim);
            margin-top: 0.25rem;
        }

        .model-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(0, 168, 255, 0.1);
            border: 1px solid var(--azurite);
            font-size: 0.7rem;
            color: var(--azurite);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .model-badge::before {
            content: '';
            width: 6px;
            height: 6px;
            background: var(--azurite);
            border-radius: 50%;
            animation: blink 2s ease-in-out infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Form elements */
        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.7rem;
            color: var(--amber-dim);
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }

        .model-id-ref {
            font-size: 0.65rem;
            color: var(--amber-dim);
            opacity: 0.7;
            margin-top: 0.35rem;
            font-family: var(--font-mono);
            letter-spacing: 0.02em;
        }

        textarea {
            width: 100%;
            min-height: 140px;
            resize: vertical;
            line-height: 1.5;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
        }

        select {
            width: 100%;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23cc8800' d='M6 8L2 4h8z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 1rem center;
            padding-right: 2.5rem;
        }

        /* Cost display */
        .cost-display {
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1.25rem;
            background: rgba(0, 217, 160, 0.08);
            border: 1px solid var(--malachite);
            margin-bottom: 1.5rem;
        }

        .cost-display .label {
            font-size: 0.65rem;
            color: var(--malachite);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .cost-display .value {
            font-size: 1.1rem;
            color: var(--malachite);
            font-weight: 600;
        }

        /* Results section */
        .results-section {
            margin-top: 2.5rem;
            padding-top: 2rem;
            border-top: 1px solid var(--shale);
        }

        .result-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .result-header h4 {
            font-size: 0.7rem;
            color: var(--amber-dim);
            text-transform: uppercase;
            letter-spacing: 0.15em;
            font-weight: 500;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.3rem 0.6rem;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            border: 1px solid;
        }

        .status-badge.success {
            color: var(--success);
            border-color: var(--success);
            background: rgba(0, 217, 160, 0.1);
        }

        .status-badge.error {
            color: var(--error);
            border-color: var(--error);
            background: rgba(255, 68, 68, 0.1);
        }

        .status-badge.pending {
            color: var(--warning);
            border-color: var(--warning);
            background: rgba(232, 232, 0, 0.1);
        }

        .status-badge::before {
            content: '';
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: currentColor;
        }

        /* Code blocks */
        .code-block {
            background: var(--obsidian);
            border: 1px solid var(--shale);
            padding: 0;
            margin-bottom: 1.5rem;
            position: relative;
        }

        .code-block::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: var(--amber-dim);
        }

        .code-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--shale);
            background: rgba(255, 176, 0, 0.03);
        }

        .code-header h5 {
            font-size: 0.7rem;
            color: var(--amber-dim);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 500;
        }

        .code-actions {
            display: flex;
            gap: 0.5rem;
        }

        .code-actions button {
            padding: 0.25rem 0.5rem;
            font-size: 0.65rem;
            background: transparent;
            border: 1px solid var(--shale);
            color: var(--amber-dim);
        }

        .code-actions button:hover {
            border-color: var(--amber-dim);
            color: var(--amber-glow);
        }

        .code-content {
            max-height: 400px;
            overflow-y: auto;
            padding: 1rem;
        }

        .code-content.collapsed {
            max-height: 0;
            padding: 0;
            overflow: hidden;
        }

        .code-block pre {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--amber-text);
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.6;
            margin: 0;
        }

        /* Scrollbar styling */
        .code-content::-webkit-scrollbar,
        .logs::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .code-content::-webkit-scrollbar-track,
        .logs::-webkit-scrollbar-track {
            background: var(--obsidian);
        }

        .code-content::-webkit-scrollbar-thumb,
        .logs::-webkit-scrollbar-thumb {
            background: var(--shale);
            border-radius: 4px;
        }

        .code-content::-webkit-scrollbar-thumb:hover,
        .logs::-webkit-scrollbar-thumb:hover {
            background: var(--amber-dim);
        }

        /* Media preview */
        .media-preview {
            margin-top: 1.5rem;
            border: 1px solid var(--shale);
            background: var(--obsidian);
            padding: 1rem;
        }

        .media-preview:empty {
            display: none;
        }

        .media-preview img,
        .media-preview video {
            max-width: 100%;
            display: block;
        }

        /* Progress bar */
        .progress-container {
            margin: 1rem 0;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--shale);
            overflow: hidden;
        }

        .progress-bar .fill {
            height: 100%;
            background: linear-gradient(90deg, var(--amber-dim), var(--amber-glow));
            transition: width 0.3s ease;
            box-shadow: 0 0 10px var(--amber-glow);
        }

        .progress-text {
            font-size: 0.75rem;
            color: var(--amber-dim);
            margin-top: 0.5rem;
        }

        /* Logs */
        .logs {
            background: var(--obsidian);
            border: 1px solid var(--shale);
            padding: 1rem;
            max-height: 250px;
            overflow-y: auto;
            font-size: 0.8rem;
        }

        .log-entry {
            padding: 0.3rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            display: flex;
            gap: 0.75rem;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-timestamp {
            color: rgba(255, 228, 160, 0.4);
            flex-shrink: 0;
        }

        .log-entry.info { color: var(--amber-text); }
        .log-entry.success { color: var(--success); }
        .log-entry.error { color: var(--error); }
        .log-entry.warning { color: var(--warning); }

        /* ===== TROUBLESHOOTING TABLE ===== */
        .error-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .error-table th,
        .error-table td {
            padding: 0.75rem 1rem;
            text-align: left;
            border-bottom: 1px solid var(--shale);
        }

        .error-table th {
            background: var(--slate);
            color: var(--amber-dim);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 500;
        }

        .error-table td {
            color: var(--amber-text);
        }

        .error-code {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            background: var(--obsidian);
            border: 1px solid var(--shale);
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--cinnabar);
        }

        .section-title {
            font-family: var(--font-display);
            font-size: 1.2rem;
            font-style: italic;
            color: var(--amber-glow);
            margin: 2.5rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--shale);
        }

        /* ===== FOOTER ===== */
        .footer {
            margin-top: 3rem;
            padding: 2rem 0;
            border-top: 1px solid var(--shale);
            text-align: center;
        }

        .footer p {
            font-size: 0.8rem;
            color: var(--amber-dim);
        }

        .footer a {
            color: var(--azurite);
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .footer a:hover {
            color: var(--amber-glow);
        }

        /* Spinner */
        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid var(--amber-dim);
            border-radius: 50%;
            border-top-color: var(--amber-glow);
            animation: spin 0.8s linear infinite;
            margin-right: 0.5rem;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Hidden utility */
        .hidden {
            display: none !important;
        }

        /* Token usage display */
        .token-usage {
            background: var(--obsidian);
            border: 1px solid var(--shale);
            padding: 1rem;
            margin-top: 1rem;
            font-size: 0.85rem;
        }

        .token-usage .row {
            display: flex;
            justify-content: space-between;
            padding: 0.3rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .token-usage .row:last-child {
            border-bottom: none;
            padding-top: 0.5rem;
            margin-top: 0.3rem;
            border-top: 1px solid var(--shale);
            font-weight: 600;
            color: var(--malachite);
        }

        .token-usage .label {
            color: var(--amber-dim);
        }

        .token-usage .value {
            color: var(--amber-text);
        }
    </style>
</head>
<body>
    <div class="noise-overlay"></div>
    
    <div class="container">
        <header>
            <div class="logo-mark">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
                </svg>
            </div>
            <h1>Gemini API Tester</h1>
            <p class="subtitle">Google Generative AI Testing Console</p>
            <div class="header-line"></div>
        </header>

        <!-- API Key Section -->
        <section class="api-key-section">
            <div class="input-row">
                <div class="input-wrapper">
                    <input type="password" id="apiKey" placeholder="Enter Gemini API Key (AIza...)" />
                    <button onclick="toggleApiKey()" class="toggle-visibility-btn" id="toggleKeyBtn" title="Show/Hide API Key">◐</button>
                </div>
                <button onclick="validateApiKey()" class="primary">Validate</button>
                <button onclick="refreshModels()" class="primary" id="refreshModelsBtn" title="Refresh available models from API">Refresh</button>
            </div>
            <div style="margin-top: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                <input type="checkbox" id="rememberKey" style="flex: none; width: 16px; height: 16px; cursor: pointer;" onchange="toggleRememberKey()" />
                <label for="rememberKey" style="font-size: 0.75rem; color: var(--amber-dim); cursor: pointer;">Remember key in browser (localStorage)</label>
            </div>
            <div style="font-size: 0.7rem; color: var(--cinnabar); margin-top: 0.5rem; opacity: 0.8;" id="storageWarning" class="hidden">
                ⚠️ Warning: Only use this for test keys. Never store production secrets in localStorage.
            </div>
            <div class="validation-result" id="keyValidationResult"></div>
        </section>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab active" onclick="showTab('image', this)" aria-label="Image Generation">
                <span class="tab-icon">◈</span>Image
            </button>
            <button class="tab" onclick="showTab('video', this)" aria-label="Video Generation">
                <span class="tab-icon">▶</span>Video
            </button>
            <button class="tab" onclick="showTab('text', this)" aria-label="Text Generation">
                <span class="tab-icon">¶</span>Text
            </button>
            <button class="tab" onclick="showTab('audio', this)" aria-label="Audio">
                <span class="tab-icon">♪</span>Audio
            </button>
            <button class="tab" onclick="showTab('troubleshoot', this)" aria-label="Diagnostics">
                <span class="tab-icon">⚙</span>Diagnostics
            </button>
        </div>

        <!-- Image Generation Panel -->
        <div id="image-panel" class="test-panel active">
            <div class="panel-header">
                <div>
                    <h3>Image Generation</h3>
                    <p>Gemini image models — Native image synthesis</p>
                </div>
                <div class="model-badge" id="imageModelBadge">gemini-2.5-flash-image</div>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label>Model</label>
                    <select id="imageModel" onchange="updateImageModelInfo()">
                        <option value="gemini-2.5-flash-image">Gemini 2.5 Flash Image</option>
                        <option value="gemini-3-pro-image-preview">Gemini 3 Pro Image Preview</option>
                    </select>
                    <div class="model-id-ref" id="imageModelIdRef">gemini-2.5-flash-image</div>
                </div>
                <div class="form-group">
                    <label>Aspect Ratio</label>
                    <select id="imageAspectRatio">
                        <option value="16:9">16:9 Landscape</option>
                        <option value="9:16">9:16 Portrait</option>
                        <option value="1:1">1:1 Square</option>
                        <option value="4:3">4:3 Standard</option>
                    </select>
                </div>
            </div>

            <div class="form-group">
                <label>Generation Prompt</label>
                <textarea id="imagePrompt">Generate a photorealistic landscape image showing: A prehistoric scene at Test Location during the Jurassic period, 150 million years ago. The landscape features lush forests with towering conifers and ferns. Dinosaurs roam the terrain. Climate: warm and humid.

Style: Photorealistic nature photography, cinematic lighting, high detail.
Aspect ratio: 16:9 (landscape orientation).
Do not include any text, labels, or watermarks in the image.</textarea>
            </div>

            <div class="cost-display" id="imageCostDisplay">
                <span class="label">Cost per Image</span>
                <span class="value" id="imagePricing">$0.039</span>
                <a href="https://ai.google.dev/pricing" target="_blank" style="font-size: 0.6rem; color: var(--azurite); margin-left: 0.5rem;">Verify pricing ↗</a>
            </div>

            <button onclick="testImageGeneration()" id="imageTestBtn" class="primary">
                Execute Generation
            </button>

            <div class="results-section" id="imageResults">
                <div class="result-header">
                    <h4>Request Payload</h4>
                </div>
                <div class="code-block" id="imageRequest">
                    <pre>// Awaiting execution...</pre>
                </div>

                <div class="result-header">
                    <h4>Response</h4>
                    <span class="status-badge hidden" id="imageStatus"></span>
                </div>
                <div class="code-block" id="imageResponse">
                    <pre>// Awaiting response...</pre>
                </div>

                <div class="media-preview" id="imagePreview"></div>

                <div class="result-header">
                    <h4>Execution Log</h4>
                </div>
                <div class="logs" id="imageLogs"></div>
            </div>
        </div>

        <!-- Video Generation Panel -->
        <div id="video-panel" class="test-panel">
            <div class="panel-header">
                <div>
                    <h3>Video Generation</h3>
                    <p>Veo 3.1 — Cinematic video synthesis with audio</p>
                </div>
                <div class="model-badge" id="videoModelBadge">veo-3.1-fast-generate-preview</div>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label>Model</label>
                    <select id="videoModel" onchange="updateVideoModelInfo()">
                        <option value="veo-3.1-fast-generate-preview">Veo 3.1 Fast</option>
                        <option value="veo-3.1-generate-preview">Veo 3.1 Standard</option>
                    </select>
                    <div class="model-id-ref" id="videoModelIdRef">veo-3.1-fast-generate-preview</div>
                </div>
                <div class="form-group">
                    <label>Duration</label>
                    <select id="videoDuration" onchange="updateVideoCost()">
                        <option value="4">4 seconds</option>
                        <option value="5">5 seconds</option>
                        <option value="6" selected>6 seconds</option>
                        <option value="8">8 seconds</option>
                    </select>
                </div>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label>Aspect Ratio</label>
                    <select id="videoAspectRatio">
                        <option value="9:16" selected>9:16 Portrait</option>
                        <option value="16:9">16:9 Landscape</option>
                        <option value="1:1">1:1 Square</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Resolution</label>
                    <select id="videoResolution">
                        <option value="720p" selected>720p</option>
                        <option value="1080p">1080p</option>
                    </select>
                </div>
            </div>

            <div class="form-group">
                <label>Video Prompt</label>
                <textarea id="videoPrompt">A cinematic video of prehistoric Earth at Test Location during the Jurassic period. 

The scene begins with a sweeping view of the ancient landscape featuring lush vegetation with cycads, ferns, and tall conifers. A Brachiosaurus slowly walks through the scene, its long neck reaching for tree tops. Pterosaurs fly overhead. 

Natural movement, documentary style cinematography, golden hour lighting, slight camera movement.

Location: California, USA
Time Period: 150 million years ago</textarea>
            </div>

            <div class="cost-display" id="videoCostEstimate">
                <span class="label">Est. Cost</span>
                <span class="value" id="videoPricing">$0.90</span>
                <a href="https://ai.google.dev/pricing" target="_blank" style="font-size: 0.6rem; color: var(--azurite); margin-left: 0.5rem;">Verify pricing ↗</a>
            </div>

            <button onclick="testVideoGeneration()" id="videoTestBtn" class="primary">
                Execute Generation
            </button>

            <div class="results-section" id="videoResults">
                <div class="result-header">
                    <h4>Request Payload</h4>
                </div>
                <div class="code-block" id="videoRequest">
                    <pre>// Awaiting execution...</pre>
                </div>

                <div class="result-header">
                    <h4>Operation Status</h4>
                    <span class="status-badge hidden" id="videoStatus"></span>
                </div>
                <div class="progress-container hidden" id="videoProgressContainer">
                    <div class="progress-bar" id="videoProgress">
                        <div class="fill" style="width: 0%"></div>
                    </div>
                    <p class="progress-text" id="videoOperationStatus">Initializing...</p>
                </div>

                <div class="result-header">
                    <h4>Response</h4>
                </div>
                <div class="code-block" id="videoResponse">
                    <pre>// Awaiting response...</pre>
                </div>

                <div class="media-preview" id="videoPreview"></div>

                <div class="result-header">
                    <h4>Execution Log</h4>
                </div>
                <div class="logs" id="videoLogs"></div>
            </div>
        </div>

        <!-- Text Generation Panel -->
        <div id="text-panel" class="test-panel">
            <div class="panel-header">
                <div>
                    <h3>Text Generation</h3>
                    <p>Gemini models — Narrative synthesis</p>
                </div>
                <div class="model-badge" id="textModelBadge">gemini-2.5-flash</div>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label>Model</label>
                    <select id="textModel" onchange="updateTextModelInfo()">
                        <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                        <option value="gemini-2.5-flash-preview-09-2025">Gemini 2.5 Flash Preview</option>
                        <option value="gemini-2.5-flash-lite">Gemini 2.5 Flash-Lite</option>
                        <option value="gemini-3-pro-preview">Gemini 3 Pro Preview</option>
                    </select>
                    <div class="model-id-ref" id="textModelIdRef">gemini-2.5-flash</div>
                </div>
                <div class="form-group">
                    <label>Temperature</label>
                    <select id="textTemperature">
                        <option value="0.0">0.0 (Deterministic)</option>
                        <option value="0.3">0.3 (Focused)</option>
                        <option value="0.7" selected>0.7 (Balanced)</option>
                        <option value="1.0">1.0 (Creative)</option>
                        <option value="1.5">1.5 (Very Creative)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Max Output Tokens</label>
                    <select id="textMaxTokens">
                        <option value="512">512</option>
                        <option value="1024">1024</option>
                        <option value="2048" selected>2048</option>
                        <option value="4096">4096</option>
                        <option value="8192">8192</option>
                    </select>
                </div>
            </div>

            <div class="form-row" id="textThinkingRow">
                <div class="form-group">
                    <label>Thinking Budget (tokens)</label>
                    <select id="textThinkingBudget">
                        <option value="0" selected>Disabled</option>
                        <option value="1024">1024</option>
                        <option value="2048">2048</option>
                        <option value="4096">4096</option>
                        <option value="8192">8192</option>
                        <option value="16384">16384</option>
                    </select>
                </div>
                <div class="form-group">
                    <label style="opacity: 0.6;">Thinking Mode</label>
                    <select disabled style="opacity: 0.6;">
                        <option>Auto (model decides)</option>
                    </select>
                </div>
            </div>
            <div style="font-size: 0.75rem; color: var(--amber-dim); margin-top: -0.5rem; margin-bottom: 1rem;">
                ⚠️ Note: Thinking tokens count toward max output tokens. If thinking budget is too high, the model may not generate text output.
            </div>

            <div class="form-group">
                <label>System Instructions</label>
                <textarea id="textSystemPrompt" style="min-height: 80px;">You are an expert AI assistant. Generate engaging and accurate responses.</textarea>
            </div>

            <div class="form-group">
                <label>User Prompt</label>
                <textarea id="textPrompt">Explain how large language models work in simple terms.</textarea>
            </div>

            <div class="cost-display" id="textCostDisplay">
                <span class="label">Pricing</span>
                <span class="value" id="textPricing">$0.30/1M in · $2.50/1M out</span>
                <a href="https://ai.google.dev/pricing" target="_blank" style="font-size: 0.6rem; color: var(--azurite); margin-left: 0.5rem;">Verify pricing ↗</a>
            </div>

            <button onclick="testTextGeneration()" id="textTestBtn" class="primary">
                Execute Generation
            </button>

            <div class="results-section" id="textResults">
                <div class="result-header">
                    <h4>Request Payload</h4>
                </div>
                <div class="code-block" id="textRequest">
                    <pre>// Awaiting execution...</pre>
                </div>

                <div class="result-header">
                    <h4>Generated Text</h4>
                    <span class="status-badge hidden" id="textStatus"></span>
                </div>
                <div class="code-block hidden" id="textPreview">
                    <div class="code-header">
                        <h5>Text Output</h5>
                        <div class="code-actions">
                            <button onclick="copyCode('textPreview')">Copy</button>
                        </div>
                    </div>
                    <div class="code-content" style="max-height: 300px;">
                        <pre id="textPreview-pre" style="white-space: pre-wrap;"></pre>
                    </div>
                </div>

                <div class="result-header" style="margin-top: 1.5rem;">
                    <h4>Full Response JSON</h4>
                </div>
                <div class="code-block" id="textResponse">
                    <pre>// Awaiting response...</pre>
                </div>

                <div class="token-usage hidden" id="tokenUsage">
                    <div class="row">
                        <span class="label">Input Tokens</span>
                        <span class="value" id="inputTokens">—</span>
                    </div>
                    <div class="row">
                        <span class="label">Output Tokens</span>
                        <span class="value" id="outputTokens">—</span>
                    </div>
                    <div class="row">
                        <span class="label">Cached Tokens</span>
                        <span class="value" id="cachedTokens">—</span>
                    </div>
                    <div class="row">
                        <span class="label">Total Cost</span>
                        <span class="value" id="totalCost">—</span>
                    </div>
                </div>

                <div class="result-header" style="margin-top: 1.5rem;">
                    <h4>Execution Log</h4>
                </div>
                <div class="logs" id="textLogs"></div>
            </div>
        </div>

        <!-- Audio Panel -->
        <div id="audio-panel" class="test-panel">
            <div class="panel-header">
                <div>
                    <h3>Audio Generation & Understanding</h3>
                    <p>Text-to-Speech synthesis and audio analysis</p>
                </div>
                <div class="model-badge" id="audioModelBadge">gemini-2.5-flash-preview-tts</div>
            </div>

            <!-- Audio Mode Toggle -->
            <div class="form-group" style="margin-bottom: 1.5rem;">
                <div style="display: flex; gap: 0.5rem;">
                    <button id="ttsModeBtnEl" class="small primary" onclick="setAudioMode('tts')">Text-to-Speech</button>
                    <button id="understandModeBtnEl" class="small" onclick="setAudioMode('understand')">Audio Understanding</button>
                </div>
            </div>

            <!-- TTS Section -->
            <div id="ttsSection">
                <div class="form-row">
                    <div class="form-group">
                        <label>TTS Model</label>
                        <select id="ttsModel" onchange="updateTTSModelInfo()">
                            <option value="gemini-2.5-flash-preview-tts">Gemini 2.5 Flash TTS</option>
                            <option value="gemini-2.5-pro-preview-tts">Gemini 2.5 Pro TTS</option>
                        </select>
                        <div class="model-id-ref" id="ttsModelIdRef">gemini-2.5-flash-preview-tts</div>
                    </div>
                    <div class="form-group">
                        <label>Voice</label>
                        <select id="ttsVoice">
                            <option value="Kore">Kore (Firm)</option>
                            <option value="Puck">Puck (Upbeat)</option>
                            <option value="Charon">Charon (Informative)</option>
                            <option value="Zephyr">Zephyr (Bright)</option>
                            <option value="Fenrir">Fenrir (Excitable)</option>
                            <option value="Leda">Leda (Youthful)</option>
                            <option value="Orus">Orus (Firm)</option>
                            <option value="Aoede">Aoede (Breezy)</option>
                            <option value="Callirrhoe">Callirrhoe (Easy-going)</option>
                            <option value="Autonoe">Autonoe (Bright)</option>
                            <option value="Enceladus">Enceladus (Breathy)</option>
                            <option value="Iapetus">Iapetus (Clear)</option>
                            <option value="Umbriel">Umbriel (Easy-going)</option>
                            <option value="Algieba">Algieba (Smooth)</option>
                            <option value="Despina">Despina (Smooth)</option>
                            <option value="Erinome">Erinome (Clear)</option>
                            <option value="Algenib">Algenib (Gravelly)</option>
                            <option value="Rasalgethi">Rasalgethi (Informative)</option>
                            <option value="Laomedeia">Laomedeia (Upbeat)</option>
                            <option value="Achernar">Achernar (Soft)</option>
                            <option value="Alnilam">Alnilam (Firm)</option>
                            <option value="Schedar">Schedar (Even)</option>
                            <option value="Gacrux">Gacrux (Mature)</option>
                            <option value="Pulcherrima">Pulcherrima (Forward)</option>
                            <option value="Achird">Achird (Friendly)</option>
                            <option value="Zubenelgenubi">Zubenelgenubi (Casual)</option>
                            <option value="Vindemiatrix">Vindemiatrix (Gentle)</option>
                            <option value="Sadachbia">Sadachbia (Lively)</option>
                            <option value="Sadaltager">Sadaltager (Knowledgeable)</option>
                            <option value="Sulafat">Sulafat (Warm)</option>
                        </select>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>Mode</label>
                        <select id="ttsSpeakerMode" onchange="toggleMultiSpeaker()">
                            <option value="single">Single Speaker</option>
                            <option value="multi">Multi-Speaker (2 voices)</option>
                        </select>
                    </div>
                </div>

                <!-- Multi-speaker config (hidden by default) -->
                <div id="multiSpeakerConfig" class="hidden" style="background: var(--obsidian); padding: 1rem; margin-bottom: 1rem; border: 1px solid var(--shale);">
                    <div class="form-row">
                        <div class="form-group">
                            <label>Speaker 1 Name</label>
                            <input type="text" id="speaker1Name" value="Speaker1" placeholder="e.g., Joe" />
                        </div>
                        <div class="form-group">
                            <label>Speaker 1 Voice</label>
                            <select id="speaker1Voice">
                                <option value="Kore">Kore (Firm)</option>
                                <option value="Puck">Puck (Upbeat)</option>
                                <option value="Charon">Charon (Informative)</option>
                                <option value="Zephyr">Zephyr (Bright)</option>
                                <option value="Aoede">Aoede (Breezy)</option>
                                <option value="Leda">Leda (Youthful)</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Speaker 2 Name</label>
                            <input type="text" id="speaker2Name" value="Speaker2" placeholder="e.g., Jane" />
                        </div>
                        <div class="form-group">
                            <label>Speaker 2 Voice</label>
                            <select id="speaker2Voice">
                                <option value="Puck">Puck (Upbeat)</option>
                                <option value="Kore">Kore (Firm)</option>
                                <option value="Charon">Charon (Informative)</option>
                                <option value="Zephyr">Zephyr (Bright)</option>
                                <option value="Aoede">Aoede (Breezy)</option>
                                <option value="Leda">Leda (Youthful)</option>
                            </select>
                        </div>
                    </div>
                    <p style="font-size: 0.7rem; color: var(--amber-dim); margin-top: 0.5rem;">
                        Format your text as: "Speaker1: Hello!\nSpeaker2: Hi there!"
                    </p>
                </div>

                <div class="form-group">
                    <label>Text to Speak</label>
                    <textarea id="ttsText" placeholder="Enter text to convert to speech...">Hello! Welcome to the Gemini API Tester. This is a demonstration of text-to-speech synthesis using Google's latest TTS models.</textarea>
                </div>

                <div class="form-group">
                    <label>Style Guidance (optional)</label>
                    <input type="text" id="ttsStyle" placeholder="e.g., Say cheerfully, whisper mysteriously, speak slowly..." />
                </div>

                <div class="cost-display" id="ttsCostDisplay">
                    <span class="label">Estimated Cost</span>
                    <span class="value" id="ttsPricing">~$0.001</span>
                    <a href="https://ai.google.dev/pricing" target="_blank" style="font-size: 0.6rem; color: var(--azurite); margin-left: 0.5rem;">Verify pricing ↗</a>
                </div>

                <button onclick="testTTS()" id="ttsTestBtn" class="primary">
                    Generate Speech
                </button>
            </div>

            <!-- Audio Understanding Section (hidden by default) -->
            <div id="understandSection" class="hidden">
                <div class="form-row">
                    <div class="form-group">
                        <label>Model</label>
                        <select id="audioUnderstandModel" onchange="updateAudioUnderstandModelInfo()">
                            <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                            <option value="gemini-2.5-flash-lite">Gemini 2.5 Flash-Lite</option>
                            <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
                        </select>
                        <div class="model-id-ref" id="audioUnderstandModelIdRef">gemini-2.5-flash</div>
                    </div>
                    <div class="form-group">
                        <label>Task</label>
                        <select id="audioTask">
                            <option value="transcribe">Transcribe</option>
                            <option value="translate">Transcribe & Translate to English</option>
                            <option value="summarize">Summarize Content</option>
                            <option value="analyze">Analyze (speakers, emotions, sounds)</option>
                            <option value="custom">Custom Prompt</option>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label>Audio File</label>
                    <div id="audioDropZone" style="border: 2px dashed var(--shale); padding: 2rem; text-align: center; cursor: pointer; transition: all 0.2s;" onclick="document.getElementById('audioFileInput').click()">
                        <input type="file" id="audioFileInput" accept="audio/*" style="display: none;" onchange="handleAudioFile(this)" />
                        <p style="color: var(--amber-dim); margin: 0;">Drop audio file here or click to browse</p>
                        <p style="font-size: 0.7rem; color: var(--amber-dim); opacity: 0.6; margin-top: 0.5rem;">Supports: WAV, MP3, AAC, FLAC, OGG, AIFF (max 20MB)</p>
                    </div>
                    <div id="audioFileInfo" class="hidden" style="margin-top: 0.5rem; padding: 0.5rem; background: var(--obsidian); border: 1px solid var(--shale);">
                        <span id="audioFileName" style="color: var(--amber-text);"></span>
                        <button onclick="clearAudioFile()" class="small" style="margin-left: 0.5rem;">Clear</button>
                    </div>
                </div>

                <div class="form-group">
                    <label>Prompt (customize task)</label>
                    <textarea id="audioPrompt" placeholder="e.g., Transcribe this audio and identify each speaker...">Transcribe this audio file accurately.</textarea>
                </div>

                <div class="cost-display" id="audioUnderstandCostDisplay">
                    <span class="label">Audio Input Cost</span>
                    <span class="value" id="audioUnderstandPricing">$1.00/1M tokens</span>
                    <span style="font-size: 0.6rem; color: var(--amber-dim); margin-left: 0.5rem;">(~32 tokens/sec)</span>
                </div>

                <button onclick="testAudioUnderstanding()" id="audioUnderstandTestBtn" class="primary">
                    Analyze Audio
                </button>
            </div>

            <!-- Results Section (shared) -->
            <div class="results-section" id="audioResults">
                <div class="result-header">
                    <h4>Request Payload</h4>
                </div>
                <div class="code-block" id="audioRequest">
                    <pre>// Awaiting execution...</pre>
                </div>

                <div class="result-header">
                    <h4>Response</h4>
                    <span class="status-badge hidden" id="audioStatus"></span>
                </div>
                <div class="code-block" id="audioResponse">
                    <pre>// Awaiting response...</pre>
                </div>

                <!-- Audio Preview for TTS -->
                <div class="media-preview" id="audioPreview"></div>

                <!-- Text Output for Understanding -->
                <div id="audioTextOutput" class="hidden" style="background: var(--obsidian); padding: 1rem; margin-top: 1rem; border: 1px solid var(--shale);">
                    <h4 style="margin-bottom: 0.5rem; color: var(--amber-glow);">Transcription / Analysis</h4>
                    <div id="audioTextResult" style="white-space: pre-wrap; line-height: 1.6;"></div>
                </div>

                <div class="result-header">
                    <h4>Execution Log</h4>
                </div>
                <div class="logs" id="audioLogs"></div>
            </div>
        </div>

        <!-- Troubleshooting Panel -->
        <div id="troubleshoot-panel" class="test-panel">
            <div class="panel-header">
                <div>
                    <h3>Diagnostics & Troubleshooting</h3>
                    <p>API error reference and system diagnostics</p>
                </div>
            </div>

            <div style="display: flex; gap: 0.75rem; margin-bottom: 1.5rem; flex-wrap: wrap;">
                <button onclick="runDiagnostics()" class="primary">
                    Run System Diagnostics
                </button>
                <button onclick="fetchAvailableModels()">
                    Fetch Available Models
                </button>
            </div>
            <div class="logs" id="diagnosticsLogs" style="min-height: 100px;"></div>
            
            <div id="availableModelsSection" class="hidden" style="margin-top: 1.5rem;">
                <h4 class="section-title">Available Models (from API)</h4>
                <div class="logs" id="modelsListLogs" style="max-height: 300px;"></div>
            </div>

            <h4 class="section-title">Error Reference</h4>
            <table class="error-table">
                <thead>
                    <tr>
                        <th>Code</th>
                        <th>Status</th>
                        <th>Description</th>
                        <th>Resolution</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><span class="error-code">400</span></td>
                        <td>INVALID_ARGUMENT</td>
                        <td>Malformed request body</td>
                        <td>Verify request format against API spec</td>
                    </tr>
                    <tr>
                        <td><span class="error-code">400</span></td>
                        <td>FAILED_PRECONDITION</td>
                        <td>Free tier unavailable in region</td>
                        <td>Enable billing in Google AI Studio</td>
                    </tr>
                    <tr>
                        <td><span class="error-code">403</span></td>
                        <td>PERMISSION_DENIED</td>
                        <td>Insufficient API key permissions</td>
                        <td>Verify API key access level</td>
                    </tr>
                    <tr>
                        <td><span class="error-code">404</span></td>
                        <td>NOT_FOUND</td>
                        <td>Resource not found</td>
                        <td>Check model name and API version</td>
                    </tr>
                    <tr>
                        <td><span class="error-code">429</span></td>
                        <td>RESOURCE_EXHAUSTED</td>
                        <td>Rate limit exceeded</td>
                        <td>Wait and retry, or request quota increase</td>
                    </tr>
                    <tr>
                        <td><span class="error-code">500</span></td>
                        <td>INTERNAL</td>
                        <td>Server-side error</td>
                        <td>Reduce context size or retry later</td>
                    </tr>
                    <tr>
                        <td><span class="error-code">503</span></td>
                        <td>UNAVAILABLE</td>
                        <td>Service overloaded</td>
                        <td>Switch models or retry later</td>
                    </tr>
                    <tr>
                        <td><span class="error-code">504</span></td>
                        <td>DEADLINE_EXCEEDED</td>
                        <td>Processing timeout</td>
                        <td>Reduce prompt size</td>
                    </tr>
                </tbody>
            </table>

            <h4 class="section-title">Rate Limits (Free Tier)</h4>
            <table class="error-table">
                <thead>
                    <tr>
                        <th>Model</th>
                        <th>RPM</th>
                        <th>RPD</th>
                        <th>TPM</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>gemini-2.5-flash</td>
                        <td>15</td>
                        <td>1,500</td>
                        <td>1,000,000</td>
                    </tr>
                    <tr>
                        <td>gemini-2.5-flash-image</td>
                        <td>10</td>
                        <td>1,500</td>
                        <td>—</td>
                    </tr>
                    <tr>
                        <td>veo-3.1-fast</td>
                        <td>2</td>
                        <td>10</td>
                        <td>—</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <footer class="footer">
            <p>
                Gemini API Tester · 
                <a href="https://ai.google.dev/gemini-api/docs" target="_blank">API Docs</a> · 
                <a href="https://ai.google.dev/pricing" target="_blank">Pricing</a> · 
                <a href="https://aistudio.google.com/" target="_blank">Get API Key</a> · 
                <a href="https://ai.google.dev/gemini-api/docs/models/gemini" target="_blank">Models</a>
            </p>
        </footer>
    </div>


    <script>
        // ============================================
        // CONSTANTS
        // ============================================
        const GEMINI_API_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta';

        const POLL_INTERVAL_MS = 10000;
        const MAX_POLL_ATTEMPTS = 30;
        const MODEL_CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour

        // ============================================
        // MODEL CONFIGURATION PRESETS (Fallbacks & Pricing)
        // These are used when API doesn't provide info
        // ============================================
        const MODEL_PRESETS = {
            // Text models - pricing per 1M tokens
            text: {
                'gemini-2.5-flash': { inputPrice: 0.30, outputPrice: 2.50, supportsThinking: true },
                'gemini-2.5-flash-lite': { inputPrice: 0.10, outputPrice: 0.40, supportsThinking: true },
                'gemini-2.5-pro': { inputPrice: 2.50, outputPrice: 15.00, supportsThinking: true },
                'gemini-3-pro-preview': { inputPrice: 2.00, outputPrice: 12.00, supportsThinking: true },
                // Default for unknown text models
                '_default': { inputPrice: 0.50, outputPrice: 2.50, supportsThinking: false }
            },
            // Image models - pricing per image
            image: {
                'gemini-2.5-flash-image': { pricePerImage: 0.039 },
                'gemini-3-pro-image-preview': { pricePerImage: 0.134 },
                'imagen-4': { pricePerImage: 0.03 },
                'imagen-4-ultra': { pricePerImage: 0.08 },
                '_default': { pricePerImage: 0.05 }
            },
            // Video models - pricing per second
            video: {
                'veo-3.1-fast-generate-preview': { pricePerSecond: 0.15 },
                'veo-3.1-generate-preview': { pricePerSecond: 0.40 },
                'veo-3': { pricePerSecond: 0.35 },
                'veo-2': { pricePerSecond: 0.25 },
                '_default': { pricePerSecond: 0.20 }
            },
            // TTS models - pricing per 1M tokens (input text, output audio)
            tts: {
                'gemini-2.5-flash-preview-tts': { inputPrice: 0.50, outputPrice: 10.00 },
                'gemini-2.5-pro-preview-tts': { inputPrice: 1.00, outputPrice: 20.00 },
                '_default': { inputPrice: 0.50, outputPrice: 10.00 }
            },
            // Audio understanding - audio input pricing per 1M tokens
            audioInput: {
                'gemini-2.5-flash': { audioInputPrice: 1.00 },
                'gemini-2.5-flash-lite': { audioInputPrice: 0.30 },
                'gemini-2.0-flash': { audioInputPrice: 0.70 },
                '_default': { audioInputPrice: 1.00 }
            }
        };

        // Configuration options per model type (not available from API)
        const TYPE_CONFIG_OPTIONS = {
            image: {
                aspectRatios: ['1:1', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '9:16', '16:9', '21:9']
            },
            video: {
                aspectRatios: ['16:9', '9:16', '1:1'],
                resolutions: ['720p', '1080p'],
                durations: [4, 5, 6, 8]
            },
            text: {
                temperatures: [0.0, 0.3, 0.7, 1.0, 1.5],
                maxTokenOptions: [512, 1024, 2048, 4096, 8192, 16384],
                thinkingBudgets: [0, 1024, 2048, 4096, 8192, 16384, 32768]
            }
        };

        // ============================================
        // DYNAMIC MODEL STATE
        // ============================================
        let discoveredModels = {
            text: [],
            image: [],
            video: [],
            tts: [],
            embedding: [],
            other: [],
            lastFetched: null,
            raw: [] // All models from API
        };

        // Legacy static models (used as fallback)
        const TEXT_MODELS = {
            'gemini-2.5-flash': { name: 'Gemini 2.5 Flash', inputPrice: 0.30, outputPrice: 2.50, supportsThinking: true, description: 'Hybrid reasoning model with 1M context' },
            'gemini-2.5-flash-lite': { name: 'Gemini 2.5 Flash-Lite', inputPrice: 0.10, outputPrice: 0.40, supportsThinking: true, description: 'Most cost-effective model' },
            'gemini-3-pro-preview': { name: 'Gemini 3 Pro Preview', inputPrice: 2.00, outputPrice: 12.00, supportsThinking: true, description: 'Best multimodal understanding' }
        };

        const IMAGE_MODELS = {
            'gemini-2.5-flash-image': { name: 'Gemini 2.5 Flash Image', pricePerImage: 0.039, description: 'Fast, flexible image generation' },
            'gemini-3-pro-image-preview': { name: 'Gemini 3 Pro Image Preview', pricePerImage: 0.134, description: 'Premium image generation' }
        };

        const VIDEO_MODELS = {
            'veo-3.1-fast-generate-preview': { name: 'Veo 3.1 Fast', pricePerSecond: 0.15, description: 'Fast video with audio' },
            'veo-3.1-generate-preview': { name: 'Veo 3.1 Standard', pricePerSecond: 0.40, description: 'High quality video with audio' }
        };

        // ============================================
        // MODEL DETECTION & CLASSIFICATION
        // ============================================
        function detectModelType(model) {
            const name = (model.name || model.baseModelId || '').replace('models/', '').toLowerCase();
            const methods = model.supportedGenerationMethods || [];
            
            // TTS models (text-to-speech)
            if (name.includes('-tts') || name.includes('tts-')) {
                return 'tts';
            }
            
            // Video models (Veo family)
            if (name.startsWith('veo-') || name.includes('veo')) {
                return 'video';
            }
            
            // Image generation models
            if (name.includes('-image') || name.startsWith('imagen-')) {
                return 'image';
            }
            
            // Embedding models
            if (name.includes('embedding') || methods.includes('embedContent') && !methods.includes('generateContent')) {
                return 'embedding';
            }
            
            // Text/multimodal generation models
            if (methods.includes('generateContent')) {
                return 'text';
            }
            
            return 'other';
        }

        function parseModelInfo(model) {
            const name = (model.name || '').replace('models/', '');
            const type = detectModelType(model);
            const displayName = model.displayName || formatModelName(name);
            const isPreview = name.includes('preview') || name.includes('experimental');
            
            // Get pricing from presets
            const typePresets = MODEL_PRESETS[type] || {};
            const preset = typePresets[name] || typePresets['_default'] || {};
            
            return {
                id: name,
                name: name,
                displayName: displayName + (isPreview ? ' (preview)' : ''),
                type: type,
                description: model.description || '',
                version: model.version || '',
                inputTokenLimit: model.inputTokenLimit,
                outputTokenLimit: model.outputTokenLimit,
                supportsThinking: model.thinking === true || preset.supportsThinking === true,
                supportedMethods: model.supportedGenerationMethods || [],
                isPreview: isPreview,
                // Pricing
                ...preset
            };
        }

        function formatModelName(modelId) {
            // Convert gemini-2.5-flash-image to "Gemini 2.5 Flash Image"
            return modelId
                .split('-')
                .map(part => {
                    if (/^\d/.test(part)) return part; // Keep version numbers as-is
                    return part.charAt(0).toUpperCase() + part.slice(1);
                })
                .join(' ');
        }

        // ============================================
        // MODEL DISCOVERY & CACHING
        // ============================================
        async function fetchAndCacheModels(forceRefresh = false) {
            const apiKey = getApiKey();
            if (!apiKey) {
                console.log('No API key, using fallback models');
                return false;
            }

            // Check cache
            const cached = localStorage.getItem('gemini_models_cache');
            if (cached && !forceRefresh) {
                try {
                    const parsed = JSON.parse(cached);
                    if (parsed.timestamp && Date.now() - parsed.timestamp < MODEL_CACHE_TTL_MS) {
                        discoveredModels = parsed.data;
                        discoveredModels.lastFetched = new Date(parsed.timestamp);
                        console.log('Loaded models from cache:', discoveredModels);
                        return true;
                    }
                } catch (e) {
                    console.warn('Failed to parse cached models:', e);
                }
            }

            try {
                const response = await fetch(`${GEMINI_API_BASE_URL}/models?key=${apiKey}`);
                if (!response.ok) {
                    console.error('Failed to fetch models:', response.status);
                    return false;
                }

                const data = await response.json();
                const models = data.models || [];
                
                // Reset categories
                discoveredModels = {
                    text: [],
                    image: [],
                    video: [],
                    embedding: [],
                    other: [],
                    lastFetched: new Date(),
                    raw: models
                };

                // Classify each model
                models.forEach(model => {
                    const parsed = parseModelInfo(model);
                    const category = parsed.type;
                    if (discoveredModels[category]) {
                        discoveredModels[category].push(parsed);
                    }
                });

                // Sort each category by name
                Object.keys(discoveredModels).forEach(key => {
                    if (Array.isArray(discoveredModels[key])) {
                        discoveredModels[key].sort((a, b) => a.id.localeCompare(b.id));
                    }
                });

                // Cache results
                localStorage.setItem('gemini_models_cache', JSON.stringify({
                    timestamp: Date.now(),
                    data: discoveredModels
                }));

                console.log('Fetched and cached models:', discoveredModels);
                return true;

            } catch (e) {
                console.error('Error fetching models:', e);
                return false;
            }
        }

        // ============================================
        // DYNAMIC DROPDOWN POPULATION
        // ============================================
        function populateModelDropdowns() {
            populateTextModels();
            populateImageModels();
            populateVideoModels();
            updateModelRefreshStatus();
        }

        function populateTextModels() {
            const select = document.getElementById('textModel');
            const models = discoveredModels.text.length > 0 ? discoveredModels.text : 
                Object.entries(TEXT_MODELS).map(([id, m]) => ({ id, ...m, displayName: m.name }));
            
            const currentValue = select.value;
            select.innerHTML = '';
            
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = model.displayName || model.name || model.id;
                option.title = model.description || '';
                select.appendChild(option);
            });

            // Restore selection or select first
            if (models.some(m => m.id === currentValue)) {
                select.value = currentValue;
            }
            updateTextModelInfo();
        }

        function populateImageModels() {
            const select = document.getElementById('imageModel');
            const models = discoveredModels.image.length > 0 ? discoveredModels.image :
                Object.entries(IMAGE_MODELS).map(([id, m]) => ({ id, ...m, displayName: m.name }));
            
            const currentValue = select.value;
            select.innerHTML = '';
            
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = model.displayName || model.name || model.id;
                option.title = model.description || '';
                select.appendChild(option);
            });

            if (models.some(m => m.id === currentValue)) {
                select.value = currentValue;
            }
            updateImageModelInfo();
        }

        function populateVideoModels() {
            const select = document.getElementById('videoModel');
            const models = discoveredModels.video.length > 0 ? discoveredModels.video :
                Object.entries(VIDEO_MODELS).map(([id, m]) => ({ id, ...m, displayName: m.name }));
            
            const currentValue = select.value;
            select.innerHTML = '';
            
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = model.displayName || model.name || model.id;
                option.title = model.description || '';
                select.appendChild(option);
            });

            if (models.some(m => m.id === currentValue)) {
                select.value = currentValue;
            }
            updateVideoModelInfo();
        }

        function updateModelRefreshStatus() {
            const statusEl = document.getElementById('modelRefreshStatus');
            if (!statusEl) return;
            
            if (discoveredModels.lastFetched) {
                const time = discoveredModels.lastFetched.toLocaleTimeString();
                const counts = `${discoveredModels.text.length}T/${discoveredModels.image.length}I/${discoveredModels.video.length}V`;
                statusEl.textContent = `Models: ${counts} · Last: ${time}`;
                statusEl.style.color = 'var(--success)';
            } else {
                statusEl.textContent = 'Using fallback models';
                statusEl.style.color = 'var(--amber-dim)';
            }
        }

        async function refreshModels() {
            const btn = document.getElementById('refreshModelsBtn');
            if (btn) {
                btn.disabled = true;
                btn.innerHTML = '<span class="spinner"></span>';
            }
            
            const success = await fetchAndCacheModels(true);
            if (success) {
                populateModelDropdowns();
            }
            
            if (btn) {
                btn.disabled = false;
                btn.innerHTML = '↻';
            }
        }

        // ============================================
        // GET MODEL INFO (Dynamic or Fallback)
        // ============================================
        function getTextModelInfo(modelId) {
            // Check discovered models first
            const discovered = discoveredModels.text.find(m => m.id === modelId);
            if (discovered) return discovered;
            
            // Fallback to static
            const fallback = TEXT_MODELS[modelId];
            if (fallback) return { id: modelId, ...fallback };
            
            // Default unknown model
            const preset = MODEL_PRESETS.text[modelId] || MODEL_PRESETS.text['_default'];
            return { id: modelId, name: modelId, displayName: formatModelName(modelId), ...preset };
        }

        function getImageModelInfo(modelId) {
            const discovered = discoveredModels.image.find(m => m.id === modelId);
            if (discovered) return discovered;
            
            const fallback = IMAGE_MODELS[modelId];
            if (fallback) return { id: modelId, ...fallback };
            
            const preset = MODEL_PRESETS.image[modelId] || MODEL_PRESETS.image['_default'];
            return { id: modelId, name: modelId, displayName: formatModelName(modelId), ...preset };
        }

        function getVideoModelInfo(modelId) {
            const discovered = discoveredModels.video.find(m => m.id === modelId);
            if (discovered) return discovered;
            
            const fallback = VIDEO_MODELS[modelId];
            if (fallback) return { id: modelId, ...fallback };
            
            const preset = MODEL_PRESETS.video[modelId] || MODEL_PRESETS.video['_default'];
            return { id: modelId, name: modelId, displayName: formatModelName(modelId), ...preset };
        }

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function getApiKey() {
            return document.getElementById('apiKey').value.trim();
        }

        // Truncate long base64 strings in JSON for display
        function truncateBase64(obj, maxLength = 100) {
            if (typeof obj !== 'object' || obj === null) return obj;
            
            if (Array.isArray(obj)) {
                return obj.map(item => truncateBase64(item, maxLength));
            }
            
            const result = {};
            for (const [key, value] of Object.entries(obj)) {
                if (key === 'data' && typeof value === 'string' && value.length > maxLength) {
                    result[key] = `${value.substring(0, maxLength)}... [${value.length} chars total]`;
                } else if (typeof value === 'object') {
                    result[key] = truncateBase64(value, maxLength);
                } else {
                    result[key] = value;
                }
            }
            return result;
        }

        // Create collapsible code block
        function createCodeBlock(id, title, content, collapsed = false) {
            const truncated = truncateBase64(content);
            const jsonStr = typeof truncated === 'string' ? truncated : JSON.stringify(truncated, null, 2);
            
            return `
                <div class="code-header">
                    <h5>${title}</h5>
                    <div class="code-actions">
                        <button onclick="toggleCodeBlock('${id}')" id="${id}-toggle">
                            ${collapsed ? 'Expand' : 'Collapse'}
                        </button>
                        <button onclick="copyCode('${id}')">Copy</button>
                    </div>
                </div>
                <div class="code-content ${collapsed ? 'collapsed' : ''}" id="${id}-content">
                    <pre id="${id}-pre">${jsonStr}</pre>
                </div>
            `;
        }

        function toggleCodeBlock(id) {
            const content = document.getElementById(`${id}-content`);
            const toggle = document.getElementById(`${id}-toggle`);
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                toggle.textContent = 'Collapse';
            } else {
                content.classList.add('collapsed');
                toggle.textContent = 'Expand';
            }
        }

        function copyCode(id) {
            const pre = document.getElementById(`${id}-pre`);
            const text = pre.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                // Visual feedback
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                btn.style.color = 'var(--success)';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.color = '';
                }, 2000);
            });
        }

        function toggleApiKey() {
            const input = document.getElementById('apiKey');
            const btn = document.getElementById('toggleKeyBtn');
            if (input.type === 'password') {
                input.type = 'text';
                btn.textContent = '◉'; // Filled circle = visible
                btn.title = 'Hide API Key';
            } else {
                input.type = 'password';
                btn.textContent = '◐'; // Half circle = hidden
                btn.title = 'Show API Key';
            }
        }

        function getTimestamp() {
            return new Date().toLocaleTimeString('en-US', { hour12: false });
        }

        function addLog(logsId, message, type = 'info') {
            const logs = document.getElementById(logsId);
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="log-timestamp">${getTimestamp()}</span><span>${message}</span>`;
            logs.appendChild(entry);
            logs.scrollTop = logs.scrollHeight;
        }

        function clearLogs(logsId) {
            document.getElementById(logsId).innerHTML = '';
        }

        function showTab(tabName, tabElement) {
            document.querySelectorAll('.test-panel').forEach(panel => panel.classList.remove('active'));
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById(`${tabName}-panel`).classList.add('active');
            tabElement.classList.add('active');
        }

        function setStatus(elementId, status, text) {
            const el = document.getElementById(elementId);
            el.className = `status-badge ${status}`;
            el.textContent = text || status.toUpperCase();
            el.classList.remove('hidden');
        }

        function hideStatus(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        // ============================================
        // MODEL INFO UPDATES (Refactored to use dynamic models)
        // ============================================
        function updateTextModelInfo() {
            const modelId = document.getElementById('textModel').value;
            if (!modelId) return;
            
            const model = getTextModelInfo(modelId);
            
            document.getElementById('textModelBadge').textContent = modelId;
            document.getElementById('textModelIdRef').textContent = modelId;
            
            const inputPrice = model.inputPrice || 0.50;
            const outputPrice = model.outputPrice || 2.50;
            document.getElementById('textPricing').textContent = 
                `$${inputPrice.toFixed(2)}/1M in · $${outputPrice.toFixed(2)}/1M out`;
            
            // Show/hide thinking budget based on model support
            const thinkingRow = document.getElementById('textThinkingRow');
            if (model.supportsThinking) {
                thinkingRow.style.display = 'grid';
            } else {
                thinkingRow.style.display = 'none';
            }
        }

        function updateImageModelInfo() {
            const modelId = document.getElementById('imageModel').value;
            if (!modelId) return;
            
            const model = getImageModelInfo(modelId);
            
            document.getElementById('imageModelBadge').textContent = modelId;
            document.getElementById('imageModelIdRef').textContent = modelId;
            const price = model.pricePerImage || 0.05;
            document.getElementById('imagePricing').textContent = `$${price.toFixed(3)}`;
        }

        function updateVideoModelInfo() {
            const modelId = document.getElementById('videoModel').value;
            if (!modelId) return;
            
            const model = getVideoModelInfo(modelId);
            
            document.getElementById('videoModelBadge').textContent = modelId;
            document.getElementById('videoModelIdRef').textContent = modelId;
            updateVideoCost();
        }

        function updateVideoCost() {
            const modelId = document.getElementById('videoModel').value;
            if (!modelId) return;
            
            const model = getVideoModelInfo(modelId);
            const duration = parseInt(document.getElementById('videoDuration').value);
            const pricePerSecond = model.pricePerSecond || 0.20;
            const cost = (duration * pricePerSecond).toFixed(2);
            
            document.getElementById('videoPricing').textContent = `$${cost}`;
        }

        // ============================================
        // LOCAL STORAGE FOR API KEY
        // ============================================
        function loadSavedApiKey() {
            const savedKey = localStorage.getItem('gemini_api_key');
            const rememberEnabled = localStorage.getItem('gemini_remember_key') === 'true';
            
            if (savedKey && rememberEnabled) {
                document.getElementById('apiKey').value = savedKey;
                document.getElementById('rememberKey').checked = true;
                document.getElementById('storageWarning').classList.remove('hidden');
            }
        }

        function toggleRememberKey() {
            const checkbox = document.getElementById('rememberKey');
            const warning = document.getElementById('storageWarning');
            
            if (checkbox.checked) {
                warning.classList.remove('hidden');
                localStorage.setItem('gemini_remember_key', 'true');
                const apiKey = getApiKey();
                if (apiKey) {
                    localStorage.setItem('gemini_api_key', apiKey);
                }
            } else {
                warning.classList.add('hidden');
                localStorage.removeItem('gemini_remember_key');
                localStorage.removeItem('gemini_api_key');
            }
        }

        function saveApiKeyIfEnabled() {
            if (document.getElementById('rememberKey').checked) {
                const apiKey = getApiKey();
                if (apiKey) {
                    localStorage.setItem('gemini_api_key', apiKey);
                }
            }
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', async () => {
            loadSavedApiKey();
            
            // Save API key when it changes
            document.getElementById('apiKey').addEventListener('input', saveApiKeyIfEnabled);
            
            // Try to load cached models or fetch new ones if we have an API key
            const apiKey = getApiKey();
            if (apiKey) {
                await fetchAndCacheModels(false); // Use cache if available
                populateModelDropdowns();
            }
            
            // Update model info displays (uses fallback if no cached models)
            updateTextModelInfo();
            updateImageModelInfo();
            updateVideoModelInfo();
            updateTTSModelInfo();
            
            // Setup audio file drag-and-drop
            const dropZone = document.getElementById('audioDropZone');
            if (dropZone) {
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.style.borderColor = 'var(--amber-glow)';
                    dropZone.style.background = 'rgba(255, 176, 0, 0.05)';
                });
                dropZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    dropZone.style.borderColor = 'var(--shale)';
                    dropZone.style.background = 'transparent';
                });
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.style.borderColor = 'var(--shale)';
                    dropZone.style.background = 'transparent';
                    const file = e.dataTransfer.files[0];
                    if (file && file.type.startsWith('audio/')) {
                        document.getElementById('audioFileInput').files = e.dataTransfer.files;
                        handleAudioFile(document.getElementById('audioFileInput'));
                    }
                });
            }
        });
        
        // Refresh models from API (called by refresh button or diagnostics)
        async function refreshModels() {
            const apiKey = getApiKey();
            const refreshBtn = document.getElementById('refreshModelsBtn');
            
            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }
            
            if (refreshBtn) {
                refreshBtn.disabled = true;
                refreshBtn.innerHTML = '<span class="spinner"></span>';
            }
            
            try {
                await fetchAndCacheModels(true); // Force refresh
                populateModelDropdowns();
                updateTextModelInfo();
                updateImageModelInfo();
                updateVideoModelInfo();
                
                if (refreshBtn) {
                    refreshBtn.innerHTML = '✓';
                    setTimeout(() => {
                        refreshBtn.innerHTML = '⟳';
                        refreshBtn.disabled = false;
                    }, 1500);
                }
            } catch (error) {
                console.error('Failed to refresh models:', error);
                if (refreshBtn) {
                    refreshBtn.innerHTML = '✗';
                    setTimeout(() => {
                        refreshBtn.innerHTML = '⟳';
                        refreshBtn.disabled = false;
                    }, 1500);
                }
            }
        }

        // ============================================
        // API KEY VALIDATION
        // ============================================
        async function validateApiKey() {
            const apiKey = getApiKey();
            const resultEl = document.getElementById('keyValidationResult');

            if (!apiKey) {
                resultEl.innerHTML = '<span style="color: var(--error);">✗ Please enter an API key</span>';
                return;
            }

            resultEl.innerHTML = '<span class="spinner"></span> Validating...';

            try {
                const response = await fetch(`${GEMINI_API_BASE_URL}/models?key=${apiKey}`);

                if (response.ok) {
                    const data = await response.json();
                    const modelCount = data.models?.length || 0;
                    resultEl.innerHTML = `<span style="color: var(--success);">✓ Valid — ${modelCount} models available</span>`;
                } else {
                    const error = await response.json();
                    resultEl.innerHTML = `<span style="color: var(--error);">✗ ${error.error?.message || response.statusText}</span>`;
                }
            } catch (error) {
                resultEl.innerHTML = `<span style="color: var(--error);">✗ Network error: ${error.message}</span>`;
            }
        }

        // ============================================
        // IMAGE GENERATION
        // ============================================
        async function testImageGeneration() {
            const apiKey = getApiKey();
            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            const modelId = document.getElementById('imageModel').value;
            const model = getImageModelInfo(modelId);
            const prompt = document.getElementById('imagePrompt').value;
            const btn = document.getElementById('imageTestBtn');

            clearLogs('imageLogs');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> Generating...';
            setStatus('imageStatus', 'pending', 'PROCESSING');
            document.getElementById('imagePreview').innerHTML = '';

            addLog('imageLogs', 'Initializing image generation...', 'info');
            addLog('imageLogs', `Model: ${modelId}`, 'info');
            const pricePerImage = model.pricePerImage || 0.05;
            addLog('imageLogs', `Cost: $${pricePerImage.toFixed(3)} per image`, 'info');

            const requestBody = {
                contents: [{
                    parts: [{ text: prompt }]
                }],
                generationConfig: {
                    responseModalities: ['IMAGE', 'TEXT']
                }
            };

            document.getElementById('imageRequest').innerHTML = createCodeBlock('imageReq', 'Request JSON', requestBody, false);

            try {
                addLog('imageLogs', `POST ${modelId}:generateContent`, 'info');

                const response = await fetch(
                    `${GEMINI_API_BASE_URL}/models/${modelId}:generateContent?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody),
                    }
                );

                const responseData = await response.json();
                document.getElementById('imageResponse').innerHTML = createCodeBlock('imageRes', 'Response JSON', responseData, true);

                if (!response.ok) {
                    throw new Error(`API Error ${response.status}: ${responseData.error?.message || 'Unknown error'}`);
                }

                addLog('imageLogs', `Response: ${response.status} OK`, 'success');

                let imageData = null;
                const candidates = responseData.candidates;
                if (candidates && candidates.length > 0) {
                    const parts = candidates[0].content?.parts || [];
                    for (const part of parts) {
                        if (part.inlineData) {
                            const { data, mimeType } = part.inlineData;
                            if (data && mimeType?.startsWith('image/')) {
                                imageData = { data, mimeType };
                                break;
                            }
                        }
                    }
                }

                if (imageData) {
                    setStatus('imageStatus', 'success', 'COMPLETE');
                    addLog('imageLogs', `Image generated: ${imageData.mimeType}`, 'success');
                    addLog('imageLogs', `Size: ${(imageData.data.length * 0.75 / 1024).toFixed(2)} KB`, 'info');

                    const previewContainer = document.getElementById('imagePreview');
                    previewContainer.innerHTML = '';
                    
                    const imgEl = document.createElement('img');
                    imgEl.src = `data:${imageData.mimeType};base64,${imageData.data}`;
                    previewContainer.appendChild(imgEl);
                    
                    // Add download button
                    const downloadBtn = document.createElement('button');
                    downloadBtn.textContent = 'Download Image';
                    downloadBtn.style.marginTop = '1rem';
                    downloadBtn.onclick = () => {
                        const link = document.createElement('a');
                        link.href = imgEl.src;
                        link.download = `gemini-image-${Date.now()}.png`;
                        link.click();
                    };
                    previewContainer.appendChild(downloadBtn);
                } else {
                    const textPart = candidates?.[0]?.content?.parts?.find(p => p.text);
                    if (textPart) {
                        addLog('imageLogs', `Text response: ${textPart.text.substring(0, 200)}...`, 'warning');
                    }
                    throw new Error('No image in response');
                }

            } catch (error) {
                setStatus('imageStatus', 'error', 'FAILED');
                addLog('imageLogs', `Error: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'Execute Generation';
            }
        }

        // ============================================
        // VIDEO GENERATION
        // ============================================
        async function testVideoGeneration() {
            const apiKey = getApiKey();
            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            const modelId = document.getElementById('videoModel').value;
            const model = getVideoModelInfo(modelId);
            const prompt = document.getElementById('videoPrompt').value;
            const duration = parseInt(document.getElementById('videoDuration').value);
            const aspectRatio = document.getElementById('videoAspectRatio').value;
            const resolution = document.getElementById('videoResolution').value;
            const btn = document.getElementById('videoTestBtn');

            const pricePerSecond = model.pricePerSecond || 0.20;
            const estimatedCost = (duration * pricePerSecond).toFixed(2);

            clearLogs('videoLogs');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> Generating...';
            setStatus('videoStatus', 'pending', 'INITIALIZING');
            document.getElementById('videoPreview').innerHTML = '';
            document.getElementById('videoProgressContainer').classList.remove('hidden');

            addLog('videoLogs', 'Initializing video generation...', 'info');
            addLog('videoLogs', `Model: ${modelId}`, 'info');
            addLog('videoLogs', `Config: ${duration}s, ${aspectRatio}, ${resolution}`, 'info');
            addLog('videoLogs', `Est. cost: $${estimatedCost}`, 'info');

            const requestBody = {
                instances: [{
                    prompt: prompt,
                }],
                parameters: {
                    aspectRatio: aspectRatio,
                    durationSeconds: duration,
                    resolution: resolution,
                    negativePrompt: 'cartoon, drawing, low quality, blur, text overlay, watermark, amateur',
                },
            };

            document.getElementById('videoRequest').innerHTML = createCodeBlock('videoReq', 'Request JSON', requestBody, false);

            try {
                addLog('videoLogs', `POST ${modelId}:predictLongRunning`, 'info');

                const startResponse = await fetch(
                    `${GEMINI_API_BASE_URL}/models/${modelId}:predictLongRunning`,
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-goog-api-key': apiKey,
                        },
                        body: JSON.stringify(requestBody),
                    }
                );

                const startData = await startResponse.json();

                if (!startResponse.ok) {
                    document.getElementById('videoResponse').innerHTML = createCodeBlock('videoRes', 'Response JSON', startData, true);
                    throw new Error(`API Error ${startResponse.status}: ${startData.error?.message || 'Unknown error'}`);
                }

                const operationId = startData.name;
                if (!operationId) {
                    throw new Error('No operation ID returned');
                }

                addLog('videoLogs', `Operation: ${operationId}`, 'success');
                document.getElementById('videoOperationStatus').textContent = `Operation: ${operationId.split('/').pop()}`;

                let attempts = 0;

                while (attempts < MAX_POLL_ATTEMPTS) {
                    attempts++;
                    const progress = Math.min((attempts / MAX_POLL_ATTEMPTS) * 100, 95);
                    document.querySelector('#videoProgress .fill').style.width = `${progress}%`;

                    addLog('videoLogs', `Polling ${attempts}/${MAX_POLL_ATTEMPTS}...`, 'info');
                    setStatus('videoStatus', 'pending', `PROCESSING ${attempts}/${MAX_POLL_ATTEMPTS}`);
                    document.getElementById('videoOperationStatus').textContent = `Processing... (${attempts}/${MAX_POLL_ATTEMPTS})`;

                    const pollResponse = await fetch(
                        `${GEMINI_API_BASE_URL}/${operationId}`,
                        {
                            method: 'GET',
                            headers: { 'x-goog-api-key': apiKey },
                        }
                    );

                    const pollData = await pollResponse.json();

                    if (pollData.error) {
                        throw new Error(`Operation failed: ${pollData.error.message}`);
                    }

                    if (pollData.done) {
                        addLog('videoLogs', 'Generation complete!', 'success');
                        document.querySelector('#videoProgress .fill').style.width = '100%';
                        document.getElementById('videoResponse').innerHTML = createCodeBlock('videoRes', 'Response JSON', pollData, true);

                        const videoUri =
                            pollData.response?.generateVideoResponse?.generatedSamples?.[0]?.video?.uri ||
                            pollData.response?.generatedVideos?.[0]?.video?.uri;

                        if (videoUri) {
                            addLog('videoLogs', `Video URI: ${videoUri.substring(0, 60)}...`, 'success');
                            addLog('videoLogs', 'Downloading video...', 'info');

                            const videoResponse = await fetch(videoUri, {
                                headers: { 'x-goog-api-key': apiKey }
                            });

                            if (videoResponse.ok) {
                                const videoBlob = await videoResponse.blob();
                                const videoUrl = URL.createObjectURL(videoBlob);

                                const previewContainer = document.getElementById('videoPreview');
                                previewContainer.innerHTML = '';
                                
                                const videoEl = document.createElement('video');
                                videoEl.src = videoUrl;
                                videoEl.controls = true;
                                videoEl.style.maxWidth = '100%';
                                previewContainer.appendChild(videoEl);
                                
                                // Add download button
                                const downloadBtn = document.createElement('button');
                                downloadBtn.textContent = 'Download Video';
                                downloadBtn.style.marginTop = '1rem';
                                downloadBtn.onclick = () => {
                                    const link = document.createElement('a');
                                    link.href = videoUrl;
                                    link.download = `gemini-video-${Date.now()}.mp4`;
                                    link.click();
                                };
                                previewContainer.appendChild(downloadBtn);

                                addLog('videoLogs', `Downloaded: ${(videoBlob.size / 1024 / 1024).toFixed(2)} MB`, 'success');
                                setStatus('videoStatus', 'success', 'COMPLETE');
                                document.getElementById('videoOperationStatus').textContent = 'Complete';
                            } else {
                                addLog('videoLogs', `Download failed: ${videoResponse.status}`, 'error');
                            }
                        } else {
                            throw new Error('No video URI in response');
                        }
                        break;
                    }

                    await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL_MS));
                }

                if (attempts >= MAX_POLL_ATTEMPTS) {
                    throw new Error('Generation timed out');
                }

            } catch (error) {
                setStatus('videoStatus', 'error', 'FAILED');
                addLog('videoLogs', `Error: ${error.message}`, 'error');
                document.getElementById('videoOperationStatus').textContent = 'Failed';
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'Execute Generation';
            }
        }



        // ============================================
        // TEXT GENERATION
        // ============================================
        async function testTextGeneration() {
            const apiKey = getApiKey();
            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            const modelId = document.getElementById('textModel').value;
            const model = getTextModelInfo(modelId);
            const systemPrompt = document.getElementById('textSystemPrompt').value;
            const userPrompt = document.getElementById('textPrompt').value;
            const temperature = parseFloat(document.getElementById('textTemperature').value);
            const maxTokens = parseInt(document.getElementById('textMaxTokens').value);
            const thinkingBudget = parseInt(document.getElementById('textThinkingBudget').value);
            const btn = document.getElementById('textTestBtn');

            clearLogs('textLogs');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> Generating...';
            setStatus('textStatus', 'pending', 'PROCESSING');
            document.getElementById('tokenUsage').classList.add('hidden');
            document.getElementById('textPreview').classList.add('hidden');

            addLog('textLogs', 'Initializing text generation...', 'info');
            addLog('textLogs', `Model: ${modelId}`, 'info');
            addLog('textLogs', `Config: temp=${temperature}, maxTokens=${maxTokens}`, 'info');
            
            // Validate thinking budget
            const supportsThinking = model.supportsThinking || false;
            if (supportsThinking && thinkingBudget > 0) {
                addLog('textLogs', `Thinking budget: ${thinkingBudget} tokens`, 'info');
                if (thinkingBudget >= maxTokens) {
                    addLog('textLogs', '⚠️ Warning: Thinking budget >= max tokens. May produce no text output.', 'warning');
                } else if (thinkingBudget > maxTokens * 0.8) {
                    addLog('textLogs', '⚠️ Thinking budget uses >80% of max tokens. Text output may be truncated.', 'warning');
                }
            }

            const generationConfig = {
                temperature: temperature,
                maxOutputTokens: maxTokens,
            };

            // Add thinking budget if supported and enabled
            if (supportsThinking && thinkingBudget > 0) {
                generationConfig.thinkingConfig = {
                    thinkingBudget: thinkingBudget
                };
            }

            const requestBody = {
                system_instruction: {
                    parts: [{ text: systemPrompt }]
                },
                contents: [{
                    role: 'user',
                    parts: [{ text: userPrompt }]
                }],
                generationConfig: generationConfig
            };

            document.getElementById('textRequest').innerHTML = createCodeBlock('textReq', 'Request JSON', requestBody, false);

            try {
                addLog('textLogs', `POST ${modelId}:generateContent`, 'info');

                const response = await fetch(
                    `${GEMINI_API_BASE_URL}/models/${modelId}:generateContent?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody),
                    }
                );

                const responseData = await response.json();
                document.getElementById('textResponse').innerHTML = createCodeBlock('textRes', 'Response JSON', responseData, true);

                if (!response.ok) {
                    throw new Error(`API Error ${response.status}: ${responseData.error?.message || 'Unknown error'}`);
                }

                addLog('textLogs', `Response: ${response.status} OK`, 'success');
                setStatus('textStatus', 'success', 'COMPLETE');

                const text = responseData.candidates?.[0]?.content?.parts?.[0]?.text;
                const finishReason = responseData.candidates?.[0]?.finishReason;
                
                if (text) {
                    addLog('textLogs', `Generated ${text.length} characters`, 'success');
                    
                    // Show text preview
                    document.getElementById('textPreview').classList.remove('hidden');
                    document.getElementById('textPreview-pre').textContent = text;
                } else {
                    document.getElementById('textPreview').classList.add('hidden');
                    
                    if (finishReason === 'MAX_TOKENS') {
                        addLog('textLogs', '⚠️ No text output: Model hit token limit during thinking phase', 'warning');
                        addLog('textLogs', 'Try: Reduce thinking budget or increase max output tokens', 'warning');
                    } else {
                        addLog('textLogs', `No text content in response (finishReason: ${finishReason})`, 'warning');
                    }
                }

                const usageMetadata = responseData.usageMetadata;
                if (usageMetadata) {
                    const inputTokens = usageMetadata.promptTokenCount || 0;
                    // Handle both old and new field names for output tokens
                    const outputTokens = usageMetadata.candidatesTokenCount || 
                                       usageMetadata.thoughtsTokenCount || 
                                       (usageMetadata.totalTokenCount - inputTokens) || 0;
                    const cachedTokens = usageMetadata.cachedContentTokenCount || 0;

                    // Use selected model's pricing
                    const inputCost = (inputTokens / 1000000) * model.inputPrice;
                    const outputCost = (outputTokens / 1000000) * model.outputPrice;
                    const totalCost = inputCost + outputCost;

                    document.getElementById('inputTokens').textContent = `${inputTokens.toLocaleString()} ($${inputCost.toFixed(6)})`;
                    document.getElementById('outputTokens').textContent = `${outputTokens.toLocaleString()} ($${outputCost.toFixed(6)})`;
                    document.getElementById('cachedTokens').textContent = cachedTokens.toLocaleString();
                    document.getElementById('totalCost').textContent = `$${totalCost.toFixed(6)}`;
                    document.getElementById('tokenUsage').classList.remove('hidden');

                    addLog('textLogs', `Tokens: ${inputTokens} in, ${outputTokens} out`, 'info');
                    addLog('textLogs', `Cost: $${totalCost.toFixed(6)} (${model.name})`, 'success');
                    if (usageMetadata.thoughtsTokenCount) {
                        addLog('textLogs', `Note: ${usageMetadata.thoughtsTokenCount} thinking tokens included`, 'info');
                    }
                }

            } catch (error) {
                setStatus('textStatus', 'error', 'FAILED');
                addLog('textLogs', `Error: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'Execute Generation';
            }
        }

        // ============================================
        // AUDIO - HELPER FUNCTIONS
        // ============================================
        
        // Current audio mode ('tts' or 'understand')
        let currentAudioMode = 'tts';
        
        // Store uploaded audio file data
        let uploadedAudioData = null;
        let uploadedAudioMimeType = null;
        let uploadedAudioName = null;
        
        function setAudioMode(mode) {
            currentAudioMode = mode;
            const ttsSection = document.getElementById('ttsSection');
            const understandSection = document.getElementById('understandSection');
            const ttsModeBtn = document.getElementById('ttsModeBtnEl');
            const understandModeBtn = document.getElementById('understandModeBtnEl');
            
            if (mode === 'tts') {
                ttsSection.classList.remove('hidden');
                understandSection.classList.add('hidden');
                ttsModeBtn.classList.add('primary');
                understandModeBtn.classList.remove('primary');
                document.getElementById('audioModelBadge').textContent = document.getElementById('ttsModel').value;
            } else {
                ttsSection.classList.add('hidden');
                understandSection.classList.remove('hidden');
                ttsModeBtn.classList.remove('primary');
                understandModeBtn.classList.add('primary');
                document.getElementById('audioModelBadge').textContent = document.getElementById('audioUnderstandModel').value;
            }
        }
        
        function toggleMultiSpeaker() {
            const mode = document.getElementById('ttsSpeakerMode').value;
            const config = document.getElementById('multiSpeakerConfig');
            if (mode === 'multi') {
                config.classList.remove('hidden');
            } else {
                config.classList.add('hidden');
            }
        }
        
        function updateTTSModelInfo() {
            const modelId = document.getElementById('ttsModel').value;
            document.getElementById('audioModelBadge').textContent = modelId;
            document.getElementById('ttsModelIdRef').textContent = modelId;
            
            // Update pricing display
            const preset = MODEL_PRESETS.tts[modelId] || MODEL_PRESETS.tts['_default'];
            const textLength = document.getElementById('ttsText').value.length;
            // Rough estimate: ~4 chars per token for English
            const estimatedTokens = Math.ceil(textLength / 4);
            const estimatedCost = (estimatedTokens / 1000000) * (preset.inputPrice + preset.outputPrice * 10);
            document.getElementById('ttsPricing').textContent = `~$${estimatedCost.toFixed(4)}`;
        }
        
        function updateAudioUnderstandModelInfo() {
            const modelId = document.getElementById('audioUnderstandModel').value;
            document.getElementById('audioModelBadge').textContent = modelId;
            document.getElementById('audioUnderstandModelIdRef').textContent = modelId;
            
            const preset = MODEL_PRESETS.audioInput[modelId] || MODEL_PRESETS.audioInput['_default'];
            document.getElementById('audioUnderstandPricing').textContent = `$${preset.audioInputPrice.toFixed(2)}/1M tokens`;
        }
        
        function handleAudioFile(input) {
            const file = input.files[0];
            if (!file) return;
            
            // Check file size (20MB limit)
            if (file.size > 20 * 1024 * 1024) {
                alert('File too large. Maximum size is 20MB for inline audio.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64 = e.target.result.split(',')[1];
                uploadedAudioData = base64;
                uploadedAudioMimeType = file.type || 'audio/mpeg';
                uploadedAudioName = file.name;
                
                document.getElementById('audioFileName').textContent = `${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
                document.getElementById('audioFileInfo').classList.remove('hidden');
            };
            reader.readAsDataURL(file);
        }
        
        function clearAudioFile() {
            uploadedAudioData = null;
            uploadedAudioMimeType = null;
            uploadedAudioName = null;
            document.getElementById('audioFileInput').value = '';
            document.getElementById('audioFileInfo').classList.add('hidden');
        }
        
        // Convert raw PCM to WAV for browser playback
        function pcmToWav(pcmData, sampleRate = 24000, numChannels = 1, bitsPerSample = 16) {
            const byteRate = sampleRate * numChannels * bitsPerSample / 8;
            const blockAlign = numChannels * bitsPerSample / 8;
            const dataSize = pcmData.length;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            
            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true); // Subchunk1Size
            view.setUint16(20, 1, true); // AudioFormat (PCM)
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(36, 'data');
            view.setUint32(40, dataSize, true);
            
            // Copy PCM data
            const pcmView = new Uint8Array(buffer, 44);
            pcmView.set(pcmData);
            
            return new Blob([buffer], { type: 'audio/wav' });
        }
        
        // ============================================
        // TEXT-TO-SPEECH GENERATION
        // ============================================
        async function testTTS() {
            const apiKey = getApiKey();
            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            const modelId = document.getElementById('ttsModel').value;
            const voice = document.getElementById('ttsVoice').value;
            const text = document.getElementById('ttsText').value;
            const style = document.getElementById('ttsStyle').value;
            const speakerMode = document.getElementById('ttsSpeakerMode').value;
            const btn = document.getElementById('ttsTestBtn');

            clearLogs('audioLogs');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> Generating...';
            setStatus('audioStatus', 'pending', 'PROCESSING');
            document.getElementById('audioPreview').innerHTML = '';
            document.getElementById('audioTextOutput').classList.add('hidden');

            addLog('audioLogs', 'Initializing text-to-speech...', 'info');
            addLog('audioLogs', `Model: ${modelId}`, 'info');
            addLog('audioLogs', `Voice: ${voice}`, 'info');
            
            // Prepare the text with optional style guidance
            let finalText = text;
            if (style) {
                finalText = `${style}: ${text}`;
            }

            // Build request body
            let requestBody;
            if (speakerMode === 'multi') {
                const speaker1Name = document.getElementById('speaker1Name').value || 'Speaker1';
                const speaker1Voice = document.getElementById('speaker1Voice').value;
                const speaker2Name = document.getElementById('speaker2Name').value || 'Speaker2';
                const speaker2Voice = document.getElementById('speaker2Voice').value;
                
                addLog('audioLogs', `Multi-speaker: ${speaker1Name}=${speaker1Voice}, ${speaker2Name}=${speaker2Voice}`, 'info');
                
                requestBody = {
                    contents: [{ parts: [{ text: finalText }] }],
                    generationConfig: {
                        responseModalities: ['AUDIO'],
                        speechConfig: {
                            multiSpeakerVoiceConfig: {
                                speakerVoiceConfigs: [
                                    {
                                        speaker: speaker1Name,
                                        voiceConfig: { prebuiltVoiceConfig: { voiceName: speaker1Voice } }
                                    },
                                    {
                                        speaker: speaker2Name,
                                        voiceConfig: { prebuiltVoiceConfig: { voiceName: speaker2Voice } }
                                    }
                                ]
                            }
                        }
                    }
                };
            } else {
                requestBody = {
                    contents: [{ parts: [{ text: finalText }] }],
                    generationConfig: {
                        responseModalities: ['AUDIO'],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: voice }
                            }
                        }
                    }
                };
            }

            document.getElementById('audioRequest').innerHTML = createCodeBlock('audioReq', 'Request JSON', requestBody, false);

            try {
                addLog('audioLogs', `POST ${modelId}:generateContent`, 'info');

                const response = await fetch(
                    `${GEMINI_API_BASE_URL}/models/${modelId}:generateContent?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody),
                    }
                );

                const responseData = await response.json();
                document.getElementById('audioResponse').innerHTML = createCodeBlock('audioRes', 'Response JSON', responseData, true);

                if (!response.ok) {
                    throw new Error(`API Error ${response.status}: ${responseData.error?.message || 'Unknown error'}`);
                }

                addLog('audioLogs', `Response: ${response.status} OK`, 'success');

                // Extract audio data
                let audioData = null;
                const candidates = responseData.candidates;
                if (candidates && candidates.length > 0) {
                    const parts = candidates[0].content?.parts || [];
                    for (const part of parts) {
                        if (part.inlineData) {
                            const { data, mimeType } = part.inlineData;
                            if (data) {
                                audioData = { data, mimeType };
                                break;
                            }
                        }
                    }
                }

                if (audioData) {
                    setStatus('audioStatus', 'success', 'COMPLETE');
                    addLog('audioLogs', `Audio generated: ${audioData.mimeType || 'audio/pcm'}`, 'success');
                    
                    // Decode base64 to raw bytes
                    const rawBytes = Uint8Array.from(atob(audioData.data), c => c.charCodeAt(0));
                    addLog('audioLogs', `Size: ${(rawBytes.length / 1024).toFixed(2)} KB`, 'info');
                    
                    // Convert PCM to WAV for playback
                    const wavBlob = pcmToWav(rawBytes, 24000, 1, 16);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    
                    const previewContainer = document.getElementById('audioPreview');
                    previewContainer.innerHTML = '';
                    
                    const audioEl = document.createElement('audio');
                    audioEl.controls = true;
                    audioEl.src = audioUrl;
                    audioEl.style.width = '100%';
                    audioEl.style.marginTop = '1rem';
                    previewContainer.appendChild(audioEl);
                    
                    // Add download button
                    const downloadBtn = document.createElement('button');
                    downloadBtn.textContent = 'Download Audio';
                    downloadBtn.style.marginTop = '1rem';
                    downloadBtn.onclick = () => {
                        const link = document.createElement('a');
                        link.href = audioUrl;
                        link.download = `gemini-tts-${Date.now()}.wav`;
                        link.click();
                    };
                    previewContainer.appendChild(downloadBtn);
                    
                    addLog('audioLogs', 'Audio ready for playback', 'success');
                } else {
                    setStatus('audioStatus', 'warning', 'NO AUDIO');
                    addLog('audioLogs', 'No audio data in response', 'warning');
                }

            } catch (error) {
                setStatus('audioStatus', 'error', 'FAILED');
                addLog('audioLogs', `Error: ${error.message}`, 'error');
                document.getElementById('audioResponse').innerHTML = `<pre style="color: var(--error);">${error.message}</pre>`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'Generate Speech';
            }
        }

        // ============================================
        // AUDIO UNDERSTANDING
        // ============================================
        async function testAudioUnderstanding() {
            const apiKey = getApiKey();
            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            if (!uploadedAudioData) {
                alert('Please upload an audio file first');
                return;
            }

            const modelId = document.getElementById('audioUnderstandModel').value;
            const task = document.getElementById('audioTask').value;
            let prompt = document.getElementById('audioPrompt').value;
            const btn = document.getElementById('audioUnderstandTestBtn');

            // Build task-specific prompt if not custom
            if (task !== 'custom') {
                const taskPrompts = {
                    'transcribe': 'Transcribe this audio file accurately. Include punctuation and speaker labels if there are multiple speakers.',
                    'translate': 'Transcribe and translate this audio to English. If already in English, just transcribe.',
                    'summarize': 'Listen to this audio and provide a concise summary of the main points discussed.',
                    'analyze': 'Analyze this audio. Identify: 1) Number of speakers, 2) Overall tone/emotion, 3) Key topics, 4) Any notable sounds or music.'
                };
                prompt = taskPrompts[task] || prompt;
                document.getElementById('audioPrompt').value = prompt;
            }

            clearLogs('audioLogs');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span> Analyzing...';
            setStatus('audioStatus', 'pending', 'PROCESSING');
            document.getElementById('audioPreview').innerHTML = '';
            document.getElementById('audioTextOutput').classList.add('hidden');

            addLog('audioLogs', 'Initializing audio understanding...', 'info');
            addLog('audioLogs', `Model: ${modelId}`, 'info');
            addLog('audioLogs', `File: ${uploadedAudioName}`, 'info');
            addLog('audioLogs', `Task: ${task}`, 'info');

            const requestBody = {
                contents: [{
                    parts: [
                        {
                            inlineData: {
                                mimeType: uploadedAudioMimeType,
                                data: uploadedAudioData
                            }
                        },
                        { text: prompt }
                    ]
                }]
            };

            // Show request but truncate the base64 data for display
            const displayRequest = JSON.parse(JSON.stringify(requestBody));
            displayRequest.contents[0].parts[0].inlineData.data = `[BASE64 AUDIO DATA - ${(uploadedAudioData.length * 0.75 / 1024).toFixed(1)} KB]`;
            document.getElementById('audioRequest').innerHTML = createCodeBlock('audioReq', 'Request JSON', displayRequest, false);

            try {
                addLog('audioLogs', `POST ${modelId}:generateContent`, 'info');

                const response = await fetch(
                    `${GEMINI_API_BASE_URL}/models/${modelId}:generateContent?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody),
                    }
                );

                const responseData = await response.json();
                document.getElementById('audioResponse').innerHTML = createCodeBlock('audioRes', 'Response JSON', responseData, true);

                if (!response.ok) {
                    throw new Error(`API Error ${response.status}: ${responseData.error?.message || 'Unknown error'}`);
                }

                addLog('audioLogs', `Response: ${response.status} OK`, 'success');

                // Extract text response
                const candidates = responseData.candidates;
                if (candidates && candidates.length > 0) {
                    const parts = candidates[0].content?.parts || [];
                    const textPart = parts.find(p => p.text);
                    
                    if (textPart) {
                        setStatus('audioStatus', 'success', 'COMPLETE');
                        addLog('audioLogs', 'Analysis complete', 'success');
                        
                        document.getElementById('audioTextResult').textContent = textPart.text;
                        document.getElementById('audioTextOutput').classList.remove('hidden');
                        
                        // Show usage if available
                        if (responseData.usageMetadata) {
                            const usage = responseData.usageMetadata;
                            addLog('audioLogs', `Tokens: ${usage.promptTokenCount} in, ${usage.candidatesTokenCount} out`, 'info');
                        }
                    } else {
                        setStatus('audioStatus', 'warning', 'NO TEXT');
                        addLog('audioLogs', 'No text in response', 'warning');
                    }
                } else {
                    setStatus('audioStatus', 'warning', 'NO RESPONSE');
                    addLog('audioLogs', 'No candidates in response', 'warning');
                }

            } catch (error) {
                setStatus('audioStatus', 'error', 'FAILED');
                addLog('audioLogs', `Error: ${error.message}`, 'error');
                document.getElementById('audioResponse').innerHTML = `<pre style="color: var(--error);">${error.message}</pre>`;
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'Analyze Audio';
            }
        }

        // ============================================
        // DIAGNOSTICS
        // ============================================
        async function runDiagnostics() {
            const apiKey = getApiKey();
            const logs = document.getElementById('diagnosticsLogs');
            logs.innerHTML = '';

            const addDiagLog = (msg, type = 'info') => {
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.innerHTML = `<span class="log-timestamp">${getTimestamp()}</span><span>${msg}</span>`;
                logs.appendChild(entry);
                logs.scrollTop = logs.scrollHeight;
            };

            if (!apiKey) {
                addDiagLog('✗ No API key provided', 'error');
                return;
            }

            addDiagLog('Starting diagnostics...', 'info');

            // Check browser capabilities
            addDiagLog('Checking browser capabilities...', 'info');
            addDiagLog(`✓ Fetch API: ${typeof fetch !== 'undefined' ? 'Available' : 'Not available'}`, 'success');
            addDiagLog(`✓ Clipboard API: ${navigator.clipboard ? 'Available' : 'Not available'}`, 'success');
            addDiagLog(`✓ LocalStorage: ${typeof localStorage !== 'undefined' ? 'Available' : 'Not available'}`, 'success');

            try {
                addDiagLog('Validating API key...', 'info');
                const response = await fetch(`${GEMINI_API_BASE_URL}/models?key=${apiKey}`);
                if (response.ok) {
                    const data = await response.json();
                    const models = data.models || [];
                    addDiagLog(`✓ API key valid — ${models.length} models accessible`, 'success');
                    
                    // Count model types
                    const genModels = models.filter(m => m.supportedGenerationMethods?.includes('generateContent'));
                    addDiagLog(`  → ${genModels.length} generation models`, 'info');
                } else {
                    const error = await response.json();
                    addDiagLog(`✗ API key invalid: ${error.error?.message}`, 'error');
                    return;
                }
            } catch (e) {
                addDiagLog(`✗ Network error: ${e.message}`, 'error');
                return;
            }

            // Check specific models used in this tool
            const modelsToCheck = [
                { name: 'gemini-2.5-flash', type: 'Text' },
                { name: 'gemini-2.5-flash-image', type: 'Image' },
                { name: 'veo-3.1-fast-generate-preview', type: 'Video' },
            ];

            addDiagLog('--- MODEL HEALTH CHECKS ---', 'info');
            for (const model of modelsToCheck) {
                try {
                    const response = await fetch(`${GEMINI_API_BASE_URL}/models/${model.name}?key=${apiKey}`);
                    if (response.ok) {
                        addDiagLog(`✓ ${model.type}: ${model.name}`, 'success');
                    } else {
                        const error = await response.json();
                        addDiagLog(`⚠ ${model.type}: ${model.name} — ${error.error?.message}`, 'warning');
                    }
                } catch (e) {
                    addDiagLog(`✗ ${model.name}: ${e.message}`, 'error');
                }
            }

            addDiagLog('--- END DIAGNOSTICS ---', 'success');
        }

        // ============================================
        // FETCH AVAILABLE MODELS (Diagnostics view)
        // ============================================
        async function fetchAvailableModels() {
            const apiKey = getApiKey();
            const section = document.getElementById('availableModelsSection');
            const logs = document.getElementById('modelsListLogs');
            
            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            section.classList.remove('hidden');
            logs.innerHTML = '';

            const addModelLog = (msg, type = 'info') => {
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.innerHTML = `<span>${msg}</span>`;
                logs.appendChild(entry);
            };

            try {
                addModelLog('Fetching and categorizing models from API...', 'info');
                
                // Use the dynamic fetch and categorize
                await fetchAndCacheModels(true);
                populateModelDropdowns();
                
                addModelLog('', 'info');
                addModelLog(`=== TEXT MODELS (${discoveredModels.text.length}) ===`, 'success');
                discoveredModels.text.forEach(m => {
                    const preset = MODEL_PRESETS.text[m.id];
                    const pricing = preset ? `$${preset.inputPrice}/$${preset.outputPrice} per 1M tokens` : 'Pricing unknown';
                    addModelLog(`• ${m.displayName} (${m.id})`, 'success');
                    addModelLog(`  ${pricing}`, 'info');
                });
                
                addModelLog('', 'info');
                addModelLog(`=== IMAGE MODELS (${discoveredModels.image.length}) ===`, 'success');
                discoveredModels.image.forEach(m => {
                    const preset = MODEL_PRESETS.image[m.id];
                    const pricing = preset ? `$${preset.pricePerImage} per image` : 'Pricing unknown';
                    addModelLog(`• ${m.displayName} (${m.id})`, 'success');
                    addModelLog(`  ${pricing}`, 'info');
                });
                
                addModelLog('', 'info');
                addModelLog(`=== VIDEO MODELS (${discoveredModels.video.length}) ===`, 'success');
                discoveredModels.video.forEach(m => {
                    const preset = MODEL_PRESETS.video[m.id];
                    const pricing = preset ? `$${preset.pricePerSecond}/sec` : 'Pricing unknown';
                    addModelLog(`• ${m.displayName} (${m.id})`, 'success');
                    addModelLog(`  ${pricing}`, 'info');
                });
                
                addModelLog('', 'info');
                addModelLog(`=== EMBEDDING MODELS (${discoveredModels.embedding.length}) ===`, 'info');
                discoveredModels.embedding.forEach(m => {
                    addModelLog(`• ${m.displayName} (${m.id})`, 'info');
                });
                
                if (discoveredModels.other.length > 0) {
                    addModelLog('', 'info');
                    addModelLog(`=== OTHER MODELS (${discoveredModels.other.length}) ===`, 'info');
                    discoveredModels.other.forEach(m => {
                        addModelLog(`• ${m.displayName} (${m.id})`, 'info');
                    });
                }
                
                const total = discoveredModels.text.length + discoveredModels.image.length + 
                              discoveredModels.video.length + discoveredModels.embedding.length + 
                              discoveredModels.other.length;
                addModelLog('', 'info');
                addModelLog(`✓ Total: ${total} models discovered and categorized`, 'success');
                addModelLog('Dropdowns have been updated with available models.', 'success');
                
            } catch (e) {
                addModelLog(`Error: ${e.message}`, 'error');
            }
        }
    </script>
</body>
</html>
